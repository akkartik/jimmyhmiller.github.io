(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[899],{3377:function(e,t,n){"use strict";n.r(t);var o=n(9292),i=n(5893);t.default=function(){return(0,i.jsxs)(o.By,{children:[(0,i.jsx)(o.Dx,{text:"Named Function Composition"}),(0,i.jsxs)("p",{children:["Some time ago I release a little library on NPM called"," ",(0,i.jsx)(o.Rh,{children:"fluent-compose"}),". I've had some mixed feelings about my creation. I know that no one has, or will use it and if they looked at it would probably dismiss it. In fact, if I hadn't written it, I would do the same. And yet, I think I've stumbled onto a fairly decent idea. By decent idea, I mean a hack. But before we dive into this hack, let's look at the situation that gave rise to it."]}),(0,i.jsxs)("p",{children:["There is this fantastic, little known library called"," ",(0,i.jsx)("a",{href:"https://zaphod.surge.sh/",children:"Zaphod"}),". The idea behind Zaphod is to mirror Clojure's immutable data API. This makes it incredibly simple to do immutable updates on plain javascript objects."]}),(0,i.jsx)(o.Q_,{children:"\n    import { update, inc } from 'zaphod/compat';\n    const state = { count: 0 };\n    update(state, 'count', inc) // { count : 1}\n  "}),(0,i.jsxs)("p",{children:["The way I've written the code above is actually not the default way Zaphod works. I imported the ",(0,i.jsx)(o.Rh,{children:"compat"})," part of zaphod. By default, the functions are exposed to take advantage of the function bind operator"," ",(0,i.jsx)(o.Rh,{children:"::"}),"."," "]}),(0,i.jsx)(o.Q_,{children:"\n    import { update, inc, dec } from 'zaphod';\n    const state = { count: 0, otherCount: 0 };\n    state::update('count', inc) // { count : 1}\n    \n    state\n        ::update('count', inc)\n        ::update('otherCount', dec)\n    // {count: 1, otherCount: -1}\n  "}),(0,i.jsxs)("p",{children:["This is actually some really neat functionality. It allows you to chain your operators together. We can build pipelines by continuing to bind. Unfortunately, we don't get function bind syntax for free. Function bind is still a stage 0 proposal. This means there is a very good possibility it will never make it into javascript. In fact, after a few years of sitting at stage 0, it is basically considered dead. There is quite a lot of risk involved in using it and more conservative configurations like"," ",(0,i.jsx)(o.Rh,{children:"create-react-app"})," wouldn't use it."]}),(0,i.jsxs)("p",{children:["But function bind syntax also has flaws even if it were accepted into the language. Function bind syntax abuses ",(0,i.jsx)(o.Rh,{children:"this"})," the most misunderstood keyword in all of javascript. The functions you write with function binding in mind must use ",(0,i.jsx)(o.Rh,{children:"this"}),", they can't be normal functions. Of course, you can wrap up those functions, but if we need to wrap functions up, why not wrap them in a way that doesn't require function bind?"]}),(0,i.jsxs)("p",{children:["This is where ",(0,i.jsx)(o.Rh,{children:"fluent-compose"})," comes in. Let's look at an example."]}),(0,i.jsx)(o.Q_,{children:"\n    import * as zaphod, { update } from 'zaphod/compat';\n    import { threadFirst, fluentCompose } from 'fluent-compose';\n    \n    const transform = fluentCompose(threadFirst(zaphod));\n    \n    const transformer = transform\n        .update('count', inc)\n        .update('otherCount', dec)\n        .set('anotherCounter', 2)\n    \n    transformer({count: 0, otherCount: 0, anotherCounter: 0})\n    // {count: 1, otherCount: -1, anotherCounter: 2}\n    \n    update({ counters: {count: 0, otherCount: 0}}, 'counters', transformer)\n    // {counters: {count: 1, otherCount: -1, anotherCounter: 2}}\n  "}),(0,i.jsxs)("p",{children:["Here we see the ",(0,i.jsx)(o.Rh,{children:"threadFirst"})," function in use. This allows us to take a collection of functions, in this case ",(0,i.jsx)(o.Rh,{children:"zaphod"}),", and wrap them up into a fluent interface. But what does this fluent interface do? It is just function composition. After calling it, we get a function back. We can now use this function to pass our data through the pipeline. Since what we get back is just a function, we can also pass this function around. We can see its use on line 14 as just a normal function that lets us perform a series of transformations on data."]}),(0,i.jsxs)("p",{children:["This is a fairly simple use of ",(0,i.jsx)(o.Rh,{children:"fluent-compose"}),", let's take it one step further."]}),(0,i.jsx)(o.Q_,{children:"\n    import * as zaphod from 'zaphod/compat';\n    import * as lodashFpCollection from 'lodash/fp/collection';\n    import { threadFirst, threadLast, fluentCompose } from 'fluent-compose';\n    \n    const zaphodTransform = threadFirst(zaphod);\n    const lodashTransform = threadLast(lodashFpCollection);\n    \n    const transform = fluentCompose({\n      ...zaphodTransform,\n      ...lodashTransform,\n    })\n    \n    const transformer = transform\n      .map(x => x + 2)\n      .filter(x => x % 2 === 2)\n      .set(0, 3)\n    \n    transformer([1,2,3,4]) // [3, 6]\n  "}),(0,i.jsxs)("p",{children:["Here we can see a combination of two totally separate libraries. In fact, I even used ",(0,i.jsx)(o.Rh,{children:"lodash/fp"})," because rather than taking its primary argument first, it makes it last. Yet, we were still able to compose these libraries in a simple, yet flexible way."," "]}),(0,i.jsxs)("p",{children:["Yet, ",(0,i.jsx)(o.Rh,{children:"fluent-compose"})," holds still more power. This time, we will be using some of the lower level features of ",(0,i.jsx)(o.Rh,{children:"fluent-compose"}),", explaining them here would be beyond the scope of this post."]}),(0,i.jsx)(o.Q_,{children:"\n    import { fluentCompose } from 'fluent-compose';\n    \n    const baseReducer = (state, action) => state;\n    \n    const initialState = prev => init => (state, action) =>\n      prev(state || init, action);\n    \n    const reduce = prev => (type, f) => (state, action) => {\n      if (action && action.type === type) {\n        return f(state, action)\n      }\n      return prev(state, action)\n    }\n    \n    const INCREMENT = 'INCREMENT';\n    const DECREMENT = 'DECREMENT';\n    \n    const increment = () => ({\n      type: INCREMENT\n    })\n    \n    const decrement = () => ({\n      type: DECREMENT\n    })\n    \n    const reducer = fluentCompose({ initialState, reduce }, baseReducer)\n    const counter = reducer\n      .initialState(0)\n      .reduce(INCREMENT, x => x + 1)\n      .reduce(DECREMENT, x => x - 1)\n    \n    console.log(\n      counter(0, increment())\n    )\n  "}),(0,i.jsxs)("p",{children:["Using ",(0,i.jsx)(o.Rh,{children:"fluent-compose"})," we've made a fluent reducer for redux! No longer would we need to write switch statements in order to make a reducer. In fact, since ",(0,i.jsx)(o.Rh,{children:"fluent-compose"})," just makes functions, you can use this reducer with combine reducers. But another really cool thing you can do with it is add on the reducer after the fact. One feature to note with this implementation is that it actually short circuits, as soon as it finds the action that matches the type, it returns, so there is no wasted computation."]}),(0,i.jsx)(o.X6,{size:"2",text:"Why do I call this a hack?"}),(0,i.jsx)("p",{children:'I really do think this library is really useful, but at the same time, I can\'t help but feel a little weird about this library. In order to make this library work, I have to take advantage of the fact that functions are objects. I am making a function and then assigning methods to it. This definitely a strange thing to do. Now, I do avoid mutating the functions passed into, I "copy" them before I assign properties to them, but it still feels like the wrong means for accomplishing the task of creating a pipeline.'}),(0,i.jsx)("p",{children:"In fact, that is the thing that makes this library a hack; it is the wrong means. This library was created out of the limitation javascript imposes on us. How would we accomplish similar things in other languages? Here are just a couple of examples."}),(0,i.jsx)(o.CN,{children:"\n    ;; Clojure\n    (->> (range 100)\n         (map (partial + 2))\n         (filter even?))\n  "}),(0,i.jsx)(o.Fz,{children:"\n    -- Haskell\n    (|>) :: a -> (a -> b) -> b\n    (|>) a f = f a\n    \n    range 100\n    |> map (+2)\n    |> filter even\n  "}),(0,i.jsx)("p",{children:"Above we see how we could accomplish similar things in Haskell and Clojure. Almost all functional programming languages have a way to do this. In fact, there are some much more powerful techniques for function composition in both Haskell and Clojure."}),(0,i.jsx)(o.X6,{size:"3",text:"Still interesting"}),(0,i.jsx)("p",{children:'At the same time, this method has some interesting features all on its own. What we have done is allow our functions to have special ways in which they compose. Each function can determine for itself special composition points. At each point along the way, we keep these composition properties, allowing us to compose further. Each of these composition methods has a name, hence "named function composition". While born out of necessity an implemented as a hack, there is something here, something interesting that might be worth exploring further. (Addendum: It has been two years and I\'ve yet to explore it further.)'})]})}},9292:function(e,t,n){"use strict";n.d(t,{By:function(){return S},CN:function(){return N},Dx:function(){return D},Ee:function(){return y},Fz:function(){return T},Mc:function(){return F},Q_:function(){return R},R4:function(){return P},Rh:function(){return M},X6:function(){return Z},rU:function(){return w}});var o=n(9499),i=n(5988),r=n.n(i),a=n(9008),s=n(1664),c=n.n(s),l=n(5675),u=n.n(l),h=n(4394),d=n(2041),f=n(8903),p=n(6410),m=n(8603),g=n(5893);function x(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function j(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?x(Object(n),!0).forEach((function(t){(0,o.Z)(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):x(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var w=c(),y=function(e){return(0,g.jsx)(u(),j({layout:"responsive"},e))},b=function(e){(0,p.Z)(e),e.languages.clojure=j(j({},e.languages.clojure),{},{number:/\b-?(0x)?\d*\.?\d+\b/g,logicVariable:/(\?|!)[a-zA-Z][a-zA-Z0-9-]+/})};b.displayName="clojure",b.aliases=[],h.Z.registerLanguage("javascript",d.Z),h.Z.registerLanguage("haskell",f.Z),h.Z.registerLanguage("clojure",b);var v=function(e){var t=e.children,n=e.right,i=e.top,r=e.left;e.buttom;return(0,g.jsx)("div",{style:(0,o.Z)({position:"absolute",right:n,left:r,top:i},"left",r),children:t})},k=function(e){var t=e.children,n=e.top,o=e.left,i=e.right,r=e.bottom;return(0,g.jsx)("div",{style:{paddingTop:n,paddingLeft:o,paddingRight:i,paddingBottom:r},children:t})},C=function(e){return function(e){var t,n,o;return(o=e.split("\n")).length>1&&o.shift(),n=function(e){return/^ */.exec(e)[0].length}((t=o)[0]),t.map((function(e){return e.substring(n,e.length)})).join("\n")}(e)},I=j(j({},m.mQ),{},{operator:{color:"#cb4b16"},logicVariable:{color:"#2aa198"},'pre[class*="language-"]':j(j({},m.mQ['pre[class*="language-"]']),{},{backgroundColor:"#fff"})}),E=function(e){var t=e.source,n=e.language;return(0,g.jsx)(h.Z,{language:n,style:I,children:C(t)})},R=function(e){var t=e.children;return(0,g.jsx)(E,{language:"javascript",source:t})},T=function(e){var t=e.children;return(0,g.jsx)(E,{language:"haskell",source:t})},N=function(e){var t=e.children;return(0,g.jsx)(E,{language:"clojure",source:t})},z=function(){return(0,g.jsx)(r(),{id:"1541984143",children:["body{font-family:helvetica,sans-serif;color:#333;line-height:1.5;}","a{color:#333;}"]})},O=function(e){var t=e.children;return(0,g.jsx)("div",{style:{margin:"0 auto",maxWidth:700},children:t})},_=function(e){var t=e.children;return(0,g.jsx)("p",{style:{fontSize:"1.5em"},children:t})},F=function(e){var t=e.items,n=e.Elem,o=void 0===n?_:n,i=e.title;return(0,g.jsxs)(g.Fragment,{children:[(0,g.jsx)(Z,{text:i}),(0,g.jsx)("ul",{children:t.map((function(e){return function(e){var t=e.href,n=e.text,o=e.Elem;return(0,g.jsx)("li",{children:(0,g.jsx)(o,{children:(0,g.jsx)(w,{href:t,children:(0,g.jsx)("a",{children:n})})})},t)}(j(j({},e),{},{Elem:o}))}))})]})},Z=function(e){var t,n=e.color,o=e.text,i=e.size;return t={1:"h1",2:"h2",3:"h3",4:"h4"}[void 0===i?1:i],(0,g.jsx)(t,{style:{color:n},children:o})},M=function(e){var t=e.children;return(0,g.jsx)("code",{style:{backgroundColor:"rgba(27,31,35,0.05)",padding:"0.2em 0.4em",borderRadius:3,fontFamily:"Monaco, monospace",fontSize:13,whiteSpace:"nowrap"},children:t})},P=function(e){var t=e.children;return(0,g.jsx)("blockquote",{style:{paddingLeft:20,margin:0,marginLeft:20,borderLeft:"0.25em solid #dfe2e5"},children:t})},D=function(e){var t=e.text;return(0,g.jsxs)(g.Fragment,{children:[(0,g.jsx)(a.default,{children:(0,g.jsx)("title",{children:t})}),(0,g.jsx)(Z,{text:t,size:1})]})},S=function(e){var t=e.children;return(0,g.jsxs)(g.Fragment,{children:[(0,g.jsxs)(a.default,{children:[(0,g.jsx)("meta",{name:"viewport",content:"width=device-width, initial-scale=1"}),(0,g.jsx)("link",{rel:"icon",href:"data:;base64,iVBORw0KGgo="}),(0,g.jsx)("meta",{name:"author",content:"Jimmy Miller"}),(0,g.jsx)("link",{rel:"alternate",type:"application/rss+xml",title:"jimmyhmiller.github.io",href:"feed.xml"})]}),(0,g.jsx)(z,{}),(0,g.jsxs)(O,{children:[(0,g.jsx)("div",{style:{position:"relative"},children:(0,g.jsx)(v,{right:0,top:0,children:(0,g.jsx)(w,{href:"/",children:(0,g.jsx)("a",{style:{textDecoration:"none"},children:(0,g.jsx)(Z,{color:"#999",text:"Jimmy Miller"})})})})}),(0,g.jsx)(k,{top:70,children:t})]})]})}},8371:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/named-function-composition",function(){return n(3377)}])}},function(e){e.O(0,[774,621,291,888,179],(function(){return t=8371,e(e.s=t);var t}));var t=e.O();_N_E=t}]);