(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[261],{8002:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/variants-and-protocols",function(){return n(4566)}])},4566:function(e,t,n){"use strict";n.r(t);var i=n(5893),r=n(1438);t.default=function(){return(0,i.jsxs)(r.By,{children:[(0,i.jsx)(r.Dx,{text:"Variants and Protocols"}),(0,i.jsx)("p",{children:"In our last post, we explored variants and the way in which they allow us to express choice. We saw that variants are much more powerful than enums because they allow you to pass values. Pattern matching on variants allows code to be explicit yet concise. However, there is still a way to make variants even more powerful, the ability to write functions that apply to multiple types of variants."}),(0,i.jsx)(r.Fz,{children:"\n    data Maybe = Nothing | Something(thing)\n  "}),(0,i.jsx)(r.Q_,{children:"\n    fn map {\n      (f, Something(x)) => Something(f(x))\n      (f, Nothing) => Nothing\n    }\n  "}),(0,i.jsx)("p",{children:"Above is our definition of the Maybe variant and its associated function, map. Just as map for a list applies a function to every element in the list, map for Maybe applies the function if there is an element. But if we defined map as we do above, it would conflict with the definition of List because they have the same name. We could just move each map definition into a module, but then we lose some of the benefits behind map. To see what that is, let's explore some different structures that work with map."}),(0,i.jsx)(r.Fz,{children:"\n    data Either = Error(e) | Success(x)\n  "}),(0,i.jsx)(r.Q_,{children:"\n    fn map {\n      (f, Error(e)) => Error(e)\n      (f, Success(x)) => Success(f(x))\n    }\n  "}),(0,i.jsx)("p",{children:"This is our first example, the Either Variant. Either allow us to have a value that is either a success or an error. If we have a success, then we want to apply our function to the successful value. If we have an error, applying a function wouldn't make much sense."}),(0,i.jsx)(r.Fz,{children:"\n    data List = Nil | Cons(x, tail)\n  "}),(0,i.jsx)(r.Q_,{children:"\n    fn map {\n      (f, Nil) => Nil\n      (f, (Cons(x, tail)) => Cons(f(x), map(f, tail))\n    }\n  "}),(0,i.jsxs)("p",{children:["Here is actually the map you are probably most familiar with, mapping over a list. And yet I'm sure this definition is new for many of you. List here is our own custom list instead of the Array from javascript. This list is a linked list, and sticking with the naming convention used for a long time, each link is built up using a constructor called ",(0,i.jsx)(r.Rh,{children:"Cons"}),". In order to map over our list, we apply it to the first element and recurse over the rest of the list."]}),(0,i.jsx)(r.Fz,{children:"\n    data Tree = Leaf(x) | Node(left, x, right)\n  "}),(0,i.jsx)(r.Q_,{children:"\n    fn map {\n      (f, Leaf(x)) => Leaf(f(x))\n      (f, Node(left, x, right)) => Node(map(f, left), f(x), map(f, right))\n    }\n  "}),(0,i.jsx)("p",{children:"Here we have a representation of a Tree. Mapping over a tree acts almost exactly like lists, a function is applied to every element, but with trees the structure is branched, so recursion needs to happen on both sides."}),(0,i.jsx)(r.Fz,{children:"\n    data Identity = Id(x)\n  "}),(0,i.jsx)(r.Q_,{children:"\n    fn map {\n      (f, Id(x)) => Id(f(x))\n    }\n  "}),(0,i.jsx)("p",{children:"This is the Identity variant. It has a completely trivial map function. We take out the x and apply f to it and then wrap it back up. This may seem pointless (there are uses), but it does show yet another use of map."}),(0,i.jsx)(r.X6,{size:"1",text:"Unifying map"}),(0,i.jsx)("p",{children:"Now that we've seen just some of the instances of how we could use map, it seems clear that just putting this in separate modules will lead to ugly code. We will have to refer to map using fully qualified names (e.g. Maybe.map, Either.map), this makes our code verbose, but also limits its reusability. As far as map is concerned, we shouldn't care if we have Maybe, Either, or Identity, as long as we have an implementation of map. In other words, we want map to be a polymorphic function."}),(0,i.jsx)("p",{children:"Protocols allow us to do exactly that, write functions that are polymorphic over a given datatype. When we pass a datatype to a function implemented as a protocol, it finds its type and dispatches to the proper function. Let's look at the Mapper protocol."}),(0,i.jsx)(r.Q_,{children:'\n    protocol Mapper {\n      fn map(x, f) {\n        """maps f over x"""\n      }\n    }\n\n    implement Mapper(Maybe) {\n      fn map {\n        (Something(x), f) => Something(f(x))\n        (Nothing, f) => Nothing\n      }\n    }\n\n    const map = (f, x) => Mapper.map(x, f);\n  '}),(0,i.jsx)("p",{children:"Here is our first protocol, the Mapper protocol. Mapper is simple, in order to implement the Mapper protocol, you need to define map. One thing to note, however, is that our definition in the protocol does differ from our definitions before by one small detail, the arguments are flipped. Protocols require the type they are going to dispatch on to be the first argument. That is why we define a simple auxiliary function that flips them back around."}),(0,i.jsx)("p",{children:"Now that we've made our protocol and defined an implementation for Maybe, we can use it on any maybe values."}),(0,i.jsx)(r.Q_,{children:"\n    map(x => x + 2, Something(2)) // Something(4)\n    map(x => x + 2, Nothing) // Nothing\n  "}),(0,i.jsx)("p",{children:"What is special about this version of map is that as long as we define a Mapper implementation for a variant, we can pass a value of that variant to the map function and it will work."}),(0,i.jsx)(r.Q_,{children:'\n    implement Mapper(Either) {\n      fn map {\n        (Error(e), f) => Error(e)\n        (Success(x), f) => Success(f(x))\n      }\n    }\n\n    map(x => x + 2, Error("error")) // Error("error")\n    map(x => x + 2, Success(2)) // Success(4)\n  '}),(0,i.jsx)("p",{children:"We can see that our map does the right thing when passed a Maybe or an Either. This is a feature with no direct counterpart in javascript. Protocols allow us to extend functionality to new data types, they allow us to build common interfaces with which we can interact, and they allow this without a nested class hierarchy or any sort of monkey patching. Protocols offer a clean way to extend functionality through out our programs. They give us a way to add new capabilities to a library as well as to use old functions in new ways."}),(0,i.jsx)(r.X6,{size:"1",text:"Conclusion"}),(0,i.jsx)("p",{children:"We have only seen a tiny glimpse into what protocols can do for us. The real power behind protocols comes when we group multiple fns together in a protocol and then build new functions that depend on that protocol. That may sound a bit abstract, but in our next post, we will dive in and implement a lodash like library that works on both built-in javascript data-structures and ImmutableJs data-structures all powered by protocols."})]})}},1438:function(e,t,n){"use strict";n.d(t,{By:function(){return F},CN:function(){return _},Dx:function(){return P},Ee:function(){return w},Fz:function(){return N},Mc:function(){return T},Q_:function(){return M},R4:function(){return O},Rh:function(){return L},X6:function(){return C},rU:function(){return g}});var i=n(5893),r=n(5988),a=n.n(r),o=n(9008),s=n(1664),l=n.n(s),c=n(7294),u=n(4394),h=n(2041),d=n(8903),f=n(6410),p=n(8603);function m(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function x(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},i=Object.keys(n);"function"===typeof Object.getOwnPropertySymbols&&(i=i.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),i.forEach((function(t){m(e,t,n[t])}))}return e}var g=l(),w=function(e){var t=e.src,n=(0,c.useState)(!1),r=n[0],a=n[1],o=r?{position:"fixed",zIndex:100,top:"50%",left:"50%",transform:"translate(-50%, -50%)",width:"80vw"}:{};return(0,i.jsxs)(i.Fragment,{children:[r&&(0,i.jsx)("div",{onClick:function(e){return a(!1)},style:{position:"fixed",top:0,left:0,width:"100vw",height:"100vh",backgroundColor:"rgb(0,0,0,0.8)"}}),(0,i.jsx)("div",{style:x({},o),children:r&&(0,i.jsx)("img",{onClick:function(){return a((function(e){return!e}))},style:{width:"100%"},src:t})}),(0,i.jsx)("img",{onClick:function(){return a((function(e){return!e}))},style:{width:"100%"},src:t})]})},y=function(e){(0,f.Z)(e),e.languages.clojure=x({},e.languages.clojure,{number:/\b-?(0x)?\d*\.?\d+\b/g,logicVariable:/(\?|!)[a-zA-Z][a-zA-Z0-9-]+/})};y.displayName="clojure",y.aliases=[],u.Z.registerLanguage("javascript",h.Z),u.Z.registerLanguage("haskell",d.Z),u.Z.registerLanguage("clojure",y);var j=function(e){var t=e.children,n=e.right,r=e.top,a=e.left;e.buttom;return(0,i.jsx)("div",{style:m({position:"absolute",right:n,left:a,top:r},"left",a),children:t})},v=function(e){var t=e.children,n=e.top,r=e.left,a=e.right,o=e.bottom;return(0,i.jsx)("div",{style:{paddingTop:n,paddingLeft:r,paddingRight:a,paddingBottom:o},children:t})},b=function(e){return function(e){var t,n=((t=e.split("\n")).length>1&&t.shift(),t),i=function(e){return/^ */.exec(e)[0].length}(n[0]);return n.map((function(e){return e.substring(i,e.length)})).join("\n")}(e)},k=x({},p.mQ,{operator:{color:"#cb4b16"},logicVariable:{color:"#2aa198"},'pre[class*="language-"]':x({},p.mQ['pre[class*="language-"]'],{backgroundColor:"#fff"})}),E=function(e){var t=e.source,n=e.language;return(0,i.jsx)(u.Z,{language:n,style:k,children:b(t)})},M=function(e){var t=e.children;return(0,i.jsx)(E,{language:"javascript",source:t})},N=function(e){var t=e.children;return(0,i.jsx)(E,{language:"haskell",source:t})},_=function(e){var t=e.children;return(0,i.jsx)(E,{language:"clojure",source:t})},S=function(){return(0,i.jsx)(a(),{id:"4dc580444c2ee173",children:"body{font-family:helvetica,sans-serif;color:#333;line-height:1.5}a{color:#333}"})},z=function(e){var t=e.children;return(0,i.jsx)("div",{style:{margin:"0 auto",maxWidth:700},children:t})},I=function(e){var t=e.children;return(0,i.jsx)("p",{style:{fontSize:"1.5em"},children:t})},T=function(e){var t=e.items,n=e.Elem,r=void 0===n?I:n,a=e.title;return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(C,{text:a}),(0,i.jsx)("ul",{children:t.map((function(e){return function(e){var t=e.href,n=e.text,r=e.Elem;return(0,i.jsx)("li",{children:(0,i.jsx)(r,{children:(0,i.jsx)(g,{href:t,children:(0,i.jsx)("a",{children:n})})})},t)}(x({},e,{Elem:r}))}))})]})},C=function(e){var t=e.color,n=e.text,r=e.size,a={1:"h1",2:"h2",3:"h3",4:"h4"}[void 0===r?1:r];return(0,i.jsx)(a,{style:{color:t},children:n})},L=function(e){var t=e.children;return(0,i.jsx)("code",{style:{backgroundColor:"rgba(27,31,35,0.05)",padding:"0.2em 0.4em",borderRadius:3,fontFamily:"Monaco, monospace",fontSize:13,whiteSpace:"nowrap"},children:t})},O=function(e){var t=e.children;return(0,i.jsx)("blockquote",{style:{paddingLeft:20,margin:0,marginLeft:20,borderLeft:"0.25em solid #dfe2e5"},children:t})},P=function(e){var t=e.text;return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(o.default,{children:(0,i.jsx)("title",{children:t})}),(0,i.jsx)(C,{text:t,size:1})]})},F=function(e){var t=e.children;return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(o.default,{children:[(0,i.jsx)("meta",{name:"viewport",content:"width=device-width, initial-scale=1"}),(0,i.jsx)("link",{rel:"icon",href:"data:;base64,iVBORw0KGgo="}),(0,i.jsx)("meta",{name:"author",content:"Jimmy Miller"}),(0,i.jsx)("link",{rel:"alternate",type:"application/rss+xml",title:"jimmyhmiller.github.io",href:"feed.xml"})]}),(0,i.jsx)(S,{}),(0,i.jsxs)(z,{children:[(0,i.jsx)("div",{style:{position:"relative"},children:(0,i.jsx)(j,{right:0,top:0,children:(0,i.jsx)(g,{href:"/",children:(0,i.jsx)("a",{style:{textDecoration:"none"},children:(0,i.jsx)(C,{color:"#999",text:"Jimmy Miller"})})})})}),(0,i.jsx)(v,{top:70,children:t})]})]})}}},function(e){e.O(0,[774,346,854,888,179],(function(){return t=8002,e(e.s=t);var t}));var t=e.O();_N_E=t}]);