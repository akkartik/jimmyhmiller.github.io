_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[23],{CQVp:function(e,t,o){(window.__NEXT_P=window.__NEXT_P||[]).push(["/protomorphism",function(){return o("sYw0")}])},sYw0:function(e,t,o){"use strict";o.r(t);var n=o("nKUr"),s=o("GyP+");t.default=function(){return Object(n.jsxs)(s.c,{children:[Object(n.jsx)(s.j,{size:"1",text:"Protomorphism"}),Object(n.jsxs)("p",{children:["The last two posts ventured off into the hypothetical world. In that world, we had a language very much like javascript but with variants and protocols. Unfortunately, that language isn't real, but that doesn't mean we can't sneak some of those ideas into our javascript. Today we are going to explore protocols further using a library called ",Object(n.jsx)("a",{href:"https://github.com/airportyh/protomorphism",children:"Protomorphism"})," that adds protocols into javascript."," "]}),Object(n.jsx)(s.f,{children:"\n      import protocol from 'protomorphism'\n\n      const Mapper = protocol({\n        map: (x, f) => {\n         // maps f over x\n        }\n      });\n\n      Mapper.implementation(Array, {\n        map: (arr, f) => arr.map(f)\n      })\n\n      const map = (f, x) => Mapper.map(x, f);\n\n      map(x => x + 2, [1,2,3]) // [3,4,5]\n    "}),Object(n.jsx)("p",{children:"Here we can see protomorphism in action with our Mapper protocol from the last post. This actually isn't too different from the code we would write in our imaginary language. What we see here is basically all of protomorphism, it is a simple library that does one thing. In fact, it is only 31 lines of code. But fewer lines doesn't mean less powerful. As promised in our last post, we are going to create our own lodash like library, but our library, using the power of protocols, will work whether we use normal Javascript Arrays, ImmutableJs Lists, or any type that implements our protocol."}),Object(n.jsx)(s.e,{size:"2",text:"Sequence Protocol"}),Object(n.jsx)(s.f,{children:"\n      const Sequence = protocol({\n        cons: (coll, elem) => {\n          // prepends elem to coll\n        },\n        first: (coll) => {\n          // gets first element of coll\n        },\n        rest: (coll) => {\n          // returns all but first element\n        },\n        isEmpty: (coll) => {\n          // returns true if empty\n        },\n        empty: (coll) => {\n          // given a coll, it will return\n          // an empty collection of the same type\n        }\n      })\n    "}),Object(n.jsx)("p",{children:"Here is our Sequence protocol from which we will build all our lodash like functions. It is a simple protocol, with only five methods, each of which is fairly straightforward. Using these we can start building up more and more useful functions. Let's start off with some very simple ones."}),Object(n.jsx)(s.e,{size:"2",text:"Examples"}),Object(n.jsx)(s.f,{children:"\n      const cons = Sequence.cons\n      const first = Sequence.first\n      const rest = Sequence.rest\n      const isEmpty = Sequence.isEmpty\n      const empty = Sequence.empty\n\n      const second = (coll) => first(rest(coll))\n      const ffirst = (coll) => first(first(coll))\n\n      const last = (coll) => {\n        if (isEmpty(coll)) {\n          return undefined\n        } else (isEmpty(rest(coll))) {\n          return first(coll)\n        } else {\n          return last(rest(coll))\n        }\n      }\n    "}),Object(n.jsxs)("p",{children:["We start off with simple aliases to our Sequence functions we need to use. This is purely for convenience's sake and not necessary. Next we implement two very simple functions, ",Object(n.jsx)(s.i,{children:"second"})," and",Object(n.jsx)(s.i,{children:" ffirst"}),". Second does what it says, it gives of the second element of a collection; ffirst gives us the first of the first element of the collection. Below should illustrate the difference clearly."]}),Object(n.jsx)(s.f,{children:"\n      const coll = [[1], [2], [3]]\n      second(coll) // [2]\n      ffirst(coll) // 1\n    "}),Object(n.jsxs)("p",{children:["The ",Object(n.jsx)(s.i,{children:"last"})," function is a little more involved, but if you are familiar with recursion it is very simple. If we are passed an empty collection, there is no last, so we return undefined. If we are passed a collection with only one thing in it, we return that thing. Otherwise, we take one item off the collection and find the last of that collection."]}),Object(n.jsx)("p",{children:"One thing to note is that these functions are perfectly comprehensible and sensible and yet we have not mentioned at all what data structure these functions are for. As far as our code is concerned, it doesn't matter if this is an array, an immutable list, or any other type. All that matters for the functions above is that the data structure implements the Sequence protocol."}),Object(n.jsx)(s.e,{size:"2",text:"Implementations"}),Object(n.jsx)(s.f,{children:"\n      Sequence.implementation(Immutable.List, {\n          cons: (coll, elem) => coll.unshift(elem),\n          empty: (coll) => Immutable.List.of(),\n          first: (coll) => coll.first(),\n          rest: (coll) => coll.rest(),\n          isEmpty: (coll) => coll.isEmpty(),\n      });\n    "}),Object(n.jsx)("p",{children:"Above is our implementation of the sequence protocol for ImmutableJs Lists. Our Sequence protocol assumes that each of our functions has no side effects, so ImmutableJs is a perfect fit here. In fact, there are methods that correspond exactly to the methods on our the Sequence protocol. Now we can use the functions we wrote on ImmutableJs Lists."}),Object(n.jsx)(s.f,{children:"\n      const coll = Immutable.fromJS([[1], [2], [3]])\n      second(coll) // List [2]\n      ffirst(coll) // 1\n    "}),Object(n.jsx)("p",{children:"This works exactly the same as the example above. In our first example, we just assumed we had an implementation of Sequence for Javascript Arrays, let's go ahead and write one now."}),Object(n.jsx)(s.f,{children:"\n      Seq.implementation(Array, {\n          cons: (coll, elem) => {\n              coll = coll.slice() // copy\n              coll.unshift(elem)\n              return coll\n          },\n          empty: (coll) => [],\n          first: (coll) => coll[0],\n          rest: (coll) => {\n              coll = coll.slice() // copy\n              coll.shift(0)\n              return coll\n          },\n          isEmpty: (coll) => coll.length == 0\n      });\n    "}),Object(n.jsx)("p",{children:"The definition for Arrays is a tad bit uglier. This is due mainly to the fact that our protocol's methods are assumed to be side-effect free, whereas Arrays methods mutate. So in order to do cons and rest, we must copy the array. Now, that we have defined the Sequence protocol for Arrays, all functions that just use protocol methods will work with Arrays."}),Object(n.jsx)(s.e,{size:"1",text:"More Functions"}),Object(n.jsx)(s.f,{children:"\n      const map = (f, coll) => {\n          if (isEmpty(coll)) {\n              return coll;\n          } else {\n              return cons(f(first(coll)), map(f, rest(coll)));\n          }\n      }\n\n      const filter = (pred, coll) => {\n          if (isEmpty(coll)) {\n              return coll;\n          } else if (pred(first(coll))) {\n              return cons(first(coll), filter(pred, rest(coll)));\n          } else {\n              return filter(pred, rest(coll));\n          }\n      }\n\n      const reduce = (f, init, coll) => {\n          if (isEmpty(coll)) {\n              return init;\n          } else {\n              return f(reduce(f, init, rest(coll)), first(coll))\n          }\n      }\n    "}),Object(n.jsx)("p",{children:"Here we have the three powerhouse lodash functions. By showing that we can implement these, it becomes easy to see how we can begin to implement all the functionality that lodash supports, but without depending on a concrete implementation."}),Object(n.jsx)(s.e,{size:"2",text:"Conclusion"}),Object(n.jsx)("p",{children:"Protocols give us the ability to reason at a higher level of abstractions. They provide us with a way to extend functionality to new code that we never planned for. This level of programming allows our code to be clear, yet powerful. In our next post, we are going to explore a similar, yet slightly different way to provide flexibility and extensibility, multi-methods."})]})}}},[["CQVp",0,2,1,3,4]]]);