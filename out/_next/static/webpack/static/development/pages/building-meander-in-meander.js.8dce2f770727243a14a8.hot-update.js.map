{"version":3,"file":"static/webpack/static/development/pages/building-meander-in-meander.js.8dce2f770727243a14a8.hot-update.js","sources":["webpack:///./pages/building-meander-in-meander.js"],"sourcesContent":["import {\n  Heading,\n  Clojure,\n  BlockQuote,\n  Term,\n  GlobalLayout,\n  Title,\n} from \"../utils.js\";\n\nexport default () => (\n  <GlobalLayout>\n    <Title text=\"Building Meander in Meander\" />\n    <p>\n      <a href=\"https://github.com/noprompt/meander/\">Meander</a> has been (in my\n      personal opinion) a wonderful success. With meander.epsilon, we can\n      express most of the data transformations we are interested. There are of\n      course a few rough edges, a few things we'd change. But as more people\n      have begun to use meander and more people present problems they are\n      tackling with meander, it becomes clear that this approach is working. And\n      yet, there is something that isn't working quite the way we'd like; the\n      implementation of the meander compiler itself.\n    </p>\n    <p>\n      This isn't meant as a diss on the code. Ultimately the organization of the\n      code is actually really nice. There are clear defined boundaries, there is\n      clear separation of functionality, the code itself isn't a mess by any\n      standard. Nor is this a diss on the quality of code generated by the\n      meander compiler. There are certainly areas that we could improve, but in\n      general meander produces code that is fast and small. In all the meander\n      matches we've written, we have never once encounter the \"method code\n      too large\" error that has plagued complex pattern matches when using\n      libraries like core.match.{\" \"}\n    </p>\n    <p>\n      But there is still something not right with the meander.epsilon compiler.\n      As you dive into the code base and try to make modifications, it becomes\n      hard to trace the way data is being transformed. The code is littered with\n      if statements needed to inspect the structure of the data we are getting.\n      Then, we have to pull out all the bits and parts we care about. What data\n      is and isn't available at a given point is far from clear. But perhaps\n      even more importantly, the shape of our data is lost. The meander.epsilon\n      compiler is really just converting between data structures, we read\n      matches in as data, parse them as an ast, build a matrix based IR, build a\n      more direct IR, do optimizations and deduplication, and then generate\n      clojure code (also data). But looking at our compiler all of this is\n      completely opaque, despite our best efforts.\n    </p>\n    <Heading size=\"2\" text=\"meander.zeta\" />\n    <p>\n      In meander.zeta we are taking a different approach. All the details\n      haven't been worked out yet, but in this article I want to share the\n      general approach so that others can understand what we are looking to\n      accomplish. In order to do that, we are actually going to build our own\n      mini-meander compiler using meander.epsilon. Our compiler will not be\n      efficient or support many matches. But it will give you a taste of what\n      meander can do, as well as give a taste of how we are using meander to\n      implement itself.\n    </p>\n    <p>\n      Before we get started though, let's talk about our plan. First in order to\n      keep our code clear and this article from stretching out forever, we are\n      going to limit our feature set to matching on logic-variables and vectors.\n      For our purposes that should be all we need. Further, we are only going to\n      be implementing the \"match\" side of meander. Substitution is\n      left as an exercise to the reader. In order to accomplish all of this\n      clearly, we will start by first implementing a parser. Then taking our AST\n      (abstract syntax tree) produced from our parser, we will implement a\n      simple meander interpreter. Finally, we will show how meander's symbolic\n      nature allows us to easily transform this interpreter into a compiler,\n      with minimal changes. Let's begin.\n    </p>\n    <Heading size=\"2\" text=\"Parser\" />\n    <p>\n      Our parser is going to mirror the format used by the meander parser. I\n      will deviate a bit, but the general approach will be the same, so you will\n      be begin to see a bit of what the internals of meander looks like. But\n      rather than build the parser first, let's describe the output we would\n      like from our parser.\n    </p>\n    <Clojure>\n      {`\n    (parse '?x)\n    ;; =>\n    {:tag :logic-variable :symbol '?x}\n\n    (parse '[?x ?y])\n    ;; =>\n    {:tag :vector\n     :sequence [{:tag :logic-variable :symbol '?x}\n                {:tag :logic-variable :symbol '?y}]}\n  `}\n    </Clojure>\n    <p>\n      Here we have two very simple examples of the input and output we expect\n      from our parser. Our goal is to take our pattern and turn it into these\n      nice, unambigious maps. These maps will always have a <Term>:tag</Term>{\" \"}\n      value and then any other keys they need to record the information our\n      interpreter or compiler might want. So, let's start by writing a parser\n      that can only handle logic-variables, then will figure out how to deal\n      with vectors.\n    </p>\n    <Clojure>\n      {`\n    (defn parse [expr]\n      (m/rewrite expr\n        (m/symbol _ (m/re #\"^\\?.+\") :as ?symbol)\n        {:tag :logic-variable\n         :symbol ?symbol}))\n\n    (parse '?x)\n    ;; =>\n    {:tag :logic-variable :symbol '?x}\n\n    (parse '?y)\n    ;; =>\n    {:tag :logic-variable :symbol '?y}\n\n    (parse 'y)\n    ;; =>\n    nil\n  `}\n    </Clojure>\n    <p>\n      This parser is very straight forward. We are taking advantage of meander's{\" \"}\n      <Term>symbol</Term> and <Term>re</Term> operators to make sure that we get\n      a symbol whose name starts with a <Term>?</Term>. Other than that, we do\n      not match on anything else and so everything else will just return nil.\n      Let's start by trying to extend this to vectors.\n    </p>\n    <Clojure>\n      {`\n    (defn parse [expr]\n      (m/rewrite expr\n        [!xs ...]\n        {:tag :vector\n         :sequence [(m/cata !xs) ...]}\n\n        (m/symbol _ (m/re #\"^\\?.*\") :as ?symbol)\n        {:tag :logic-variable\n         :symbol ?symbol}))\n\n    (parse '[?x ?y])\n    ;; =>\n    {:tag :vector\n     :sequence\n     [{:tag :logic-variable, :symbol ?x}\n      {:tag :logic-variable, :symbol ?y}]}\n  `}\n    </Clojure>\n    <p>\n      Here we pull out all the contents of our vector and use{\" \"}\n      <Term>m/cata</Term> to recursively parse our input. If you have never used\n      cata you can think of it just like recur but for patterns. With that we\n      have written our parser as far as we need to for our purposes.\n    </p>\n    <Heading size=\"2\" text=\"Interpreter\" />\n    <p>\n      Now that we have an ast, we can write a simple interpreter. What our\n      interpreter will do is given an input and a pattern and an evironment, we\n      will return an environment with all our logic variables set to some value,\n      or we will return <Term>:fail</Term>. Rather than try to assemble our\n      interpreter piece by piece, I wil begin by showing you the entire thing.\n    </p>\n    <Clojure>\n      {`\n    (defn interpret [expr target env]\n      (m/match [expr target env]\n\n        [{:tag :logic-variable :symbol ?symbol} ?target ?env]\n        (if (contains? ?env ?symbol)\n          (if (= ?target (get ?env ?symbol))\n            ?env\n            :fail)\n          (assoc ?env ?symbol ?target))\n\n        [{:tag :vector :sequence ()} ?target ?env]\n        ?env\n\n        [{:tag :vector :sequence (?x)} ?target ?env]\n        (interpret ?x (nth ?target 0) ?env)\n\n        [{:tag :vector :sequence (?x & ?rest)} ?target ?env]\n        (interpret {:tag :vector :sequence ?rest}\n                   (subvec ?target 1)\n                   (interpret ?x (nth ?target 0) ?env))))\n\n    (interpret (parse '[?x ?y]) [1 2] {})\n\n    ;; =>\n    {'?x 1 '?y 2}\n  `}\n    </Clojure>\n    <p>\n      If you've written an interpreter before this shouldn't be too suprising.\n      First we handle logic variables by looking them up in the evironment. We\n      handle the cases of the logic variable existing in the environment and\n      matching, it existing and not matching, and it not existing. Next we\n      handle some vectors cases. Here we handle the empty case, the single\n      element case, and the case with more than one element. This interpreter\n      does in fact work for the input we've given it. But think about what would\n      happen if we did the same pattern but just passed a single number? We'd\n      throw an error, because we never actually check that our input is a\n      vector. We could just go and add a vector check to all of our vector\n      cases, but that means we will be checking that something is a vector for\n      every single element of our vector. So let's try a different apporach.\n    </p>\n    <Clojure>\n      {`\n    (defn interpret [expr target env]\n      (m/match [expr target env]\n\n        [{:tag :logic-variable :symbol ?symbol} ?target ?env]\n        (if (contains? ?env ?symbol)\n          (if (= ?target (get ?env ?symbol))\n            ?env\n            :fail)\n          (assoc ?env ?symbol ?target))\n\n        ;; Ensure target is a vector\n        [{:tag :vector :checked nil :sequence ?sequence} ?target ?env]\n        (if (vector? ?target)\n          (interpret {:tag :vector :checked true :sequence ?sequence} ?target ?env)\n          :fail)\n\n        [{:tag :vector :sequence ()} ?target ?env]\n        ?env\n\n        [{:tag :vector :sequence (?x)} ?target ?env]\n        (interpret ?x (nth ?target 0) ?env)\n\n        [{:tag :vector :checked ?checked :sequence (?x & ?rest)} ?target ?env]\n        (interpret {:tag :vector :checked ?checked :sequence ?rest}\n                   (subvec ?target 1)\n                   (interpret ?x (nth ?target 0) ?env))))\n  `}\n    </Clojure>\n    <p>\n      Taking advantage of the fact that meander matches are ordered, we added an\n      earlier match that will perform the check for us and then when we recurse\n      we simply set checked to true. That means, this pattern will no longer\n      match and we can continue with the interpreter as before. There is still a\n      problem with this interpreter that we aren't going to fix in this post, it\n      does not check the size of the vector. For our purposes, doing this would\n      actually be fairly easy, we check the size of <Term>?sequence</Term> and\n      ensure target has the same size. But what would we do if we added repeats\n      (e.g. <Term>...</Term>, <Term>..1</Term> etc)? For now we will leave this\n      off, but this might be a good exercise for thinking about on your own.\n    </p>\n    <p>\n      Now that we have a working interpreter, let's look at how we can make this\n      a compiler. Doing so with meander will actually be suprisingly easy.\n    </p>\n    <Heading size=\"2\" text=\"Compiler\" />\n    <p>\n      Our transition from interpreter to compiler will be simpler than any I\n      have seen before. In fact, the translation is basically mechanical. Here\n      is our first version of our compiler.{\" \"}\n    </p>\n    <Clojure>\n      {`\n    (defn compile [expr target env]\n      (m/rewrite [expr target env]\n\n        [{:tag :logic-variable :symbol ?symbol} ?target ?env]\n        (if (contains? ?env ('quote ?symbol))\n          (if (= ?target (get ?env ('quote ?symbol)))\n            ?env\n            :fail)\n          (assoc ?env ('quote ?symbol) ?target))\n\n        ;; Ensure target is a vector\n        [{:tag :vector :checked nil :sequence ?sequence} ?target ?env]\n        (if (vector? ?target)\n          (m/cata [{:tag :vector :checked true :sequence ?sequence} ?target ?env])\n          :fail)\n\n        [{:tag :vector :sequence ()} ?target ?env]\n        ?env\n\n        [{:tag :vector :sequence (?x)} ?target ?env]\n        (m/cata [?x (nth ?target 0) ?env])\n\n        [{:tag :vector :checked ?checked :sequence (?x & ?rest)} ?target ?env]\n        (m/cata [{:tag :vector :checked ?checked :sequence ?rest}\n                 (subvec ?target 1)\n                 (m/cata [?x (nth ?target 0) ?env])])))\n  `}\n    </Clojure>\n    <p>\n      At first glance it might actually be quite hard to spot the difference.\n      There are actually only a few differences here. First and most crucially\n      is that we have changed from <Term> m/match</Term> to{\" \"}\n      <Term>m/rewrite</Term>. So now instead of our right hand side being code\n      that will be immediately run, it is actually data that we are outputing,\n      in this case that data is code. Secondly we have quoted some of our\n      symbols. Because we will ultimately be outputing this code in a macro and\n      looking up symbols in an environment, they need to be quoted. Finally we\n      have changed from clojure recursive function calls, to using meanders\n      recursion operator <Term>m/cata</Term>. These are our only real changes\n      and given that, we can now make a macro for matching that will compile our\n      pattern.\n    </p>\n    <Clojure>{`\n    (defmacro match [target expr]\n        (let [target_sym (gensym \"target_\")\n              env_sym (gensym \"env_\")]\n          \\`(let [~target_sym ~target\n                 ~env_sym {}]\n             ~(compile (parse expr) target_sym env_sym))))\n\n    (match [1 2 1] [?x ?y ?x])\n    ;; => {?x 1 ?y 2}\n    (match [1 2 2] [?x ?y ?x])\n    ;; => :fail\n  `}</Clojure>\n    <p>\n      No longer is there a runtime cost to parsing our pattern and then\n      interpretive overhead for crawling through the ast deciding what code to\n      run. All of this happens in our macroexpansion. But there is one small\n      problem. If we look at the code generated by this compiler, we will see\n      that it is rather repetitive and long for what it does.This occurs because\n      of the following clause above:\n    </p>\n    <Clojure>\n      {`\n    [{:tag :vector :checked ?checked :sequence (?x & ?rest)} ?target ?env]\n    (m/cata [{:tag :vector :checked ?checked :sequence ?rest}\n             (subvec ?target 1)\n             (m/cata [?x (nth ?target 0) ?env])])\n  `}\n    </Clojure>\n    <p>\n      Line 4 here is the culprit for our explosion of code. Ultimately our\n      compilation returns us an expression that returns an evironment. We build\n      up this environment as we go through our vector. Line 4 allows us to do\n      exactly that, expand into some code that will update our environment. But\n      it does this over and over again. As we continue our compilation our{\" \"}\n      <Term>?env</Term> becomes more and more branching code. Luckily there is a\n      pretty simple fix for this.\n    </p>\n    <Clojure>\n      {`\n     (m/and [{:tag :vector :checked ?checked :sequence (?x & ?rest)} ?target ?env]\n            (m/let [?env-sym (gensym \"_env_\")]))\n          (let [?env-sym (m/cata [?x (nth ?target 0) ?env])]\n            (m/cata [{:tag :vector :checked ?checked :sequence ?rest}\n                     (subvec ?target 1)\n                     ?env-sym]))\n  `}\n    </Clojure>\n    <p>\n      Here is our updated code that no longer creates a huge compilation output.\n      Rather than directly updating our <Term>?env</Term> by emedding more and\n      more code. We make a new symbol that will store our environment and pass\n      that down through our recursion. Now that we have solved that problem we\n      end up with some fairly reasonable generated code.\n    </p>\n    <Clojure>\n      {`\n    (let\n      [target_19362 [1 2 1] env_19363 {}]\n      (if (vector? target_19362)\n        (let*\n          [_env_19364\n           (if (contains? env_19363 '?x)\n             (if (= (nth target_19362 0) (get env_19363 '?x))\n               env_19363\n               :fail)\n             (assoc env_19363 '?x (nth target_19362 0)))]\n          (let\n            [_env_19365\n             (if (contains? _env_19364 '?y)\n               (if (= (nth (subvec target_19362 1) 0) (get _env_19364 '?y))\n                 _env_19364\n                 :fail)\n               (assoc _env_19364 '?y (nth (subvec target_19362 1) 0)))]\n            (if (contains? _env_19365 '?x)\n              (if (=\n                    (nth (subvec (subvec target_19362 1) 1) 0)\n                    (get _env_19365 '?x))\n                _env_19365\n                :fail)\n              (assoc\n                _env_19365\n                '?x\n                (nth (subvec (subvec target_19362 1) 1) 0)))))\n        :fail))\n  `}\n    </Clojure>\n    <p>\n      Admittedly this is still quiet a bit of code for what we are doing. If you\n      look at it for even a moment you can see some issues. We definitely run\n      nth and subvec entirely too many times. But once we look back at code it\n      becomes pretty obvious that the gensym trick we used before could easy\n      solve that problem. But there is also something still a bit unsatisfying\n      about this generated code. Shouldn't it just be simpler? We know that{\" \"}\n      <Term>?y</Term> is only assigned once so why check if it is in the\n      environment or not yet? We also know that the first thing we match on{\" \"}\n      <Term>?x</Term> will always succeed. Why are we checking there as well? In\n      fact, the case we are looking at now, we know that our input is a vector\n      and in fact, we know exactly what our output should be at compile because\n      we were passed a literal!\n    </p>\n    <p>\n      These sorts of optimizations are completely possible with this framework.\n      We don't have the space to fully explore them, but I will just give a\n      general flavor. What if during compile time we also kept a compile time\n      env of all the things we know? So we know that our input is a vector, so\n      why check that at run time? We know exactly which logic-variables have\n      been bound or not, so <Term>?x</Term> can just be directly assigned to{\" \"}\n      <Term>(nth ?target 0)</Term> right away. Hopefully you can see that there\n      is nothing about this approach that stops us from making these sorts of\n      optimizations in the future.\n    </p>\n    <Heading size=\"2\" text=\"Conclusion\" />\n    <p>\n      I hope that from this post you learned how meander can be incredibly\n      useful when building out a compiler in clojure. Its direct, symbolic,\n      pattern matching approach simplifies a great deal of what goes into\n      writing a compiler for your own customer dsl. It gives you clear and\n      concise code that lets you reason about your cases. As we've built out\n      zeta we've found meander's structured approach to really help us\n      understand our code and really give us a clear sense of what to do next.\n      Give this technique a try the next time you have a dsl in mind. Why settle\n      for an interpreter when meander makes it this easy to write a compiler?\n    </p>\n  </GlobalLayout>\n);\n"],"mappings":";;;;;;;;;;;;;;;;;AAAA;AASA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAtZA;;;;A","sourceRoot":""}