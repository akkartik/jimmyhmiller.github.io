{"version":3,"file":"static/webpack/static/development/pages/card-driven-development.js.6f0196b79a79da059d4e.hot-update.js","sources":["webpack:///./pages/card-driven-development.js"],"sourcesContent":["import {\n  Heading,\n  GlobalLayout,\n  Title,\n} from \"../utils.js\";\n\n\nexport default () => (\n  <GlobalLayout>\n    <Title text=\"Card Driven Development\" />\n    <p>\n      Every company I've worked for has practiced what I call \"Card Driven\n      Development\" (CDD). CDD is an umbrella term meant to encompass quite\n      a few different development processes. The name comes from the use\n      \"cards\" (digital or physical) found in the Scrum and Kanban\n      processes as a means of organizing work, but CDD extends further than\n      these two processes. It encompasses formal or informal processes as long\n      as they have a few things in common.\n    </p>\n    <p>\n      CDD is a way of approaching software development that involves a splitting\n      of responsibilities. In CDD, there must be at least two groups, the first,\n      often called \"Engineering\", is responsible for technical duties\n      including writing code, maintaining code, and operational concerns like\n      managing servers. The second group, often known as \"Product\" or\n      informally \"the business\", is responsible for researching,\n      detailing, and prioritizing what work needs to be done. Product gives work\n      to Engineering, they prioritize what work will be done next, and they\n      message out the status of the work to various interested parties.\n    </p>\n    <p>\n      This split in responsibility means that the day to day work accomplished\n      by Engineering and Product looks very different. Engineering, when\n      operating well, is about shipping working software to customers, whereas\n      Product's work is an act of delegation. This can often lead engineers to\n      believe that Product does nothing, but this could not be further from the\n      truth. Product's days are packed with work. Product's role involves being\n      pulled in many directions, they must keep track of the work in progress,\n      while continuously engaging with the various interested parties vying for\n      their attention; attempting to get their parties particular needs worked\n      on next. Product's work involves status updates, meetings, research, and\n      above all else detailing and prioritizing work for Engineering.\n    </p>\n    <Heading size=\"2\" text=\"The Card\" />\n    <p>\n      This last part is where the Card makes its appearance. The work needed to\n      be done is too large to write down and detail in its entirety. Even if\n      this task could be achieved, it isn't desirable because by the time it\n      were written down, the facts on the ground may have changed. So a system\n      of dividing work is adopted. In CDD this system is the card.\n    </p>\n    <p>\n      Cards are a place to describe work that needs to be done and in what order\n      it should be done in. Cards break work into small chunks, typically\n      focused on functionality that some particular party would like. Cards\n      serve as a meeting point for Product and Engineering. Product writes\n      cards, prioritizes cards, and gives them to Engineering as work that needs\n      to be done. Engineering then works in the order given by product.\n      Sometimes this means taking multiple cards at a time and making a time\n      commitment for their completion (often called a sprint). Other times cards\n      are pulled in one by one as time and resources permit (this process is\n      often referred to as a Kanban-style workflow).\n    </p>\n    <p>\n      As described here the card making process only involves Product. In\n      reality, there is usually a collaboration between Product and Engineering\n      around cards. Typically cards are reviewed and discussed before they ever\n      are handed to an Engineer to be worked on. Some of these cards may be\n      \"technical cards\", cards created and owned by Engineering. With\n      the exception of these technical cards though, cards are ultimately owned\n      by Product. Product has the final say in the priority of cards and also\n      serves as the \"acceptor\" for the fact that the work described in\n      cards has been accomplished.\n    </p>\n    <p>\n      The above is meant to serve as a neutral description of what is entailed\n      by CDD. I imagine the process as I've described above is familiar to most\n      reading this. CDD is a process that many companies adopt and do so for\n      good reason. But despite the best of intentions by companies that adopt\n      CDD, it is ultimately a disastrous process that leads to some of the worst\n      issues plaguing modern software development. My contention is that\n      companies that adopt CDD will inevitably exacerbate these issues, leading\n      to engineer dissatisfaction and ultimately decrease productivity.\n    </p>\n    <Heading size=\"2\" text=\"A Bit About Creating Software\" />\n    <p>\n      Creating software is a complex task. Features, that may seem on the\n      surface trivial, may involve multiple months of effort, minor\n      modifications to an existing process may cause a cascade of required\n      changes across many code bases, and seemingly innocent changes may\n      introduce pernicious bugs. While there are most certainly ways to mitigate\n      these problems, this is the reality the Software Engineer faces. The\n      development of software does not exist in a vacuum, our new code must\n      continue to work with old code, our legacy systems require continual\n      maintenance, and the interactions between pieces of our system continue to\n      grow in complexity.{\" \"}\n    </p>\n    <p>\n      Any view about how creating software ought to be done needs a realistic\n      picture of the constraints that Software Engineers face. The software\n      creation process at any given time is constrained by all the decisions of\n      past engineers who had a hand in building the software in question. But\n      this set of decisions involves not only all engineers who have worked at\n      the company, but also the authors of the libraries on which the software\n      is built. The design decisions of past engineers provide deep constraints\n      on how much effort a given change will take. The choice of a relational or\n      non-relational datastore limits the sort of data-integrity constraints we\n      can easily enforce, the library we have chosen for our frontend constrains\n      our ability to support things like server side rendering that may be\n      needed for SSO considerations, and the decision of how to split (or not)\n      our application into services constrains our deployment and delivery\n      strategy, just to name a few examples.\n    </p>\n    <Heading size=\"2\" text=\"The Problem with Card Driven Development\" />\n    <p>\n      Card Driven Development, as I have defined it, is concerned primarily with\n      a division of labor. But with this division of labor comes a division of\n      knowledge. Engineering has knowledge of the software systems needed for\n      the business to operate and Product has knowledge of the various\n      interested parties desires. In themselves, these divisions aren't an\n      issue, but as I hope to show the process of CDD limits the sharing of\n      knowledge across these domains, causing issues for both the software being\n      created and the larger goals of the business.\n    </p>\n    <p>\n      What precisely do I mean by CDD limiting knowledge? As I'm using this term\n      it implies at least two things. First that the knowledge that is shared\n      between Product and Engineering happens at the wrong level and in the\n      wrong order, limiting the usefulness of the knowledge transfer. Second,\n      that the sorts of knowledge shared between Product and Engineering allows\n      neither to accomplish their job as well as they ought. The recipricol\n      nature of this issue is incredibly important. CDD isn't just bad for\n      Engineering, it is bad for Product and ultimately bad for the business.\n    </p>\n    <Heading size=\"3\" text=\"Wrong Level, Wrong Order\" />\n    <p>\n      Imagine you are a novice cook looking to tackle a recipe a bit above your\n      skill level. You follow the instructions step by step diligently, spending\n      close to an hour on prepping and cooking the ingredients and as you come\n      to the end of the recipe it says, \"To finish the dish, poach an egg\n      and place it on top\". You immediately become frustrated. While the\n      recipe is telling you everything needed to make the dish, you have no idea\n      how to poach an egg and even if you figure it out, poaching takes time and\n      your dish is already complete.\n    </p>\n    <p>\n      Unlike our cooking example, CDD gives engineers knowledge at a far too\n      granular level. Cards are about tiny pieces of functionality. They don't\n      provide the context needed to place a given piece of functionality into\n      its larger context. This focus on granularity can cause the big picture to\n      be lost. It isn't uncommon to implement an entire card based on the\n      details it provided just to find out that it didn't actually solve the\n      problem it was intended to. Had the card been written at a higher level,\n      the constraints on what counted as a solution to the problem would have\n      been clearer.\n    </p>\n    <p>\n      But not only is the information too granular, it is often delivered out of\n      order. It isn't uncommon to work on 2 or 3 cards, make great progress and\n      then once you reach the next card you find out the work you just\n      implemented was wrong. What you learned on card 4 was the information you\n      really needed at the beginning. This new feature or constraint casts all\n      previous work in a different light. The assumptions you made when\n      implementing the others cards are now invalid. This means you have one of\n      two choices, rework the previous work, or write a hack. I think we all\n      know what happens most often.\n    </p>\n    <Heading size=\"3\" text=\"Wrong Sorts of Knowledge\" />\n    <p>\n      Cards detail functional requirements of our software. They are more often\n      than not about the inputs and outputs of our systems. They detail UI\n      components, data requirements, user interactions, etc... And yet these are\n      not what Engineering needs to do its job most effectively. The businesses\n      we create are not about these inputs and outputs. Ultimately as businesses\n      we are trying to solve problems. Our users face issues that we are\n      providing a service to solve. These users may be our internal customer\n      support, other companies, or consumers, regardless, they have a problem\n      and we are tasked with fixing it.\n    </p>\n    <p>\n      In order for these problems to be fixed software needs to be written by\n      Engineering. How can Engineering know if their software is effective? Or\n      in other words, how can Engineering know if their software solves the\n      users problem? By first understanding at a deep level what problem the\n      user is actually facing. This is truly the fundamental problem with CDD,\n      it distances engineers from the problems they are solving. No longer do\n      engineers know or care deeply about these problems. No longer do they\n      spend their time thinking about these problems and how best to solve them.\n      Instead they are consumed my details, consumed by sub-optimal answers.\n    </p>\n    <p>\n      But this isn't just a problem for Engineering. Product has actually\n      burdened themselves unncessarily by adopting CDD. Product's job is to\n      understand the user, but there is never just one user. Product has to\n      understand all these various users with vastly different needs. This is a\n      hard enough task on its own, but with CDD understanding the users is a\n      small part. Instead Product must spend their time trying to fit these\n      problems into the system that Engineering has developed. They must figure\n      out a way to address the problems the user is facing in a system that is\n      largely opaque to them.{\" \"}\n    </p>\n    <p>\n      The opaque nature of the system that Engineering has built is a constant\n      frustration for Product. Constantly their best attempts at making small\n      changes are thwarted. Even the most reasonable sounding request gets push\n      back from Engineering. It becomes harder and harder for product to make\n      the changes they are requesting. Ultimately, in CDD Product is being asked\n      to do something nearly impossible, propose changes to a system that is\n      largely invisible to them. Try as they might, knowing the difference\n      between what changes can easily be made to the system and what are hard\n      are completely opaque to Product, and yet their job depends on knowing\n      exactly that.\n    </p>\n    <Heading size=\"3\" text=\"Bad for the Business\" />\n    <p>\n      Engineers who lack understanding of the users problems may in fact solve\n      the wrong problems. This might mean shipping a feature that no one uses.\n      It might mean removing some feature that was actually important. It may\n      mean leaving out a feature that was sorely needed. All of these problems\n      can drive customers away or prevent a company from gaining more customers.\n      If the users of the system are internal, it may cause inefficiencies that\n      cost the company money and can even effect employee morale.\n    </p>\n    <p>\n      If Product has been tasked with designing new features and lacks the\n      knowledge needed to do so effectively, inefficiencies in the development\n      cycle can appear. As Product proposes more changes, estimates grow. More\n      time is spent in meetings discussing changes than actual time implementing\n      them. As development slows, demands for changes continue to grow. Users\n      talking to Product get increasingly frustrated as to why their changes\n      haven't made it in. More often than not, this means changes to internal\n      tools are deprioritized leading to inefficiencies and frustrating process\n      that can lead to high turn over in customer support.\n    </p>\n    <Heading size=\"2\" text=\"Strained Relationships and Failure\" />\n    <p>\n      This lack of knowledge on both sides can lead to friction between Product\n      and Engineering. It is incredibly common for companies to have a strained\n      relationship between Engineering and Product. I think many of these issues\n      stem from this confusion of roles. Both sides feel powerless to achieve\n      the ends they have been tasked with. Over time their jobs get harder and\n      harder and it always seems to be the other groups fault.\n    </p>\n    <p>\n      A strained Product and Engineering relationship can spell the end for a\n      project or even a whole company. More often than not, strained product\n      relationship leads to frustrated engineers. These engineers leave, taking\n      with them they hard-earned knowledge of the system they helped build. As\n      engineers become frustrated, they often become defensive. When asked for\n      estimates they worry how the estimates might be used and so they pad them.\n      Knowing that anyone can detect if they constantly over-estimate, they slow\n      their work, meeting nearly exactly the estimates they put forward.\n    </p>\n    <p>\n      Development time stretches on and on. The system the company has invested\n      so much in grows worse and worse to make changes to. All the original\n      engineers have left. Product is sick and tried of trying to force changes\n      through. Ultimately the business decides to do the big rewrite and the\n      cycle repeats. If we are ever to break this cycle, we must get rid of card\n      driven development. What I think should replace it is a topic for another\n      post, but I will say that whatever will must start with an understanding\n      of <Link href=\"/defending-incommunicability\">what programming is</Link>.\n    </p>\n  </GlobalLayout>\n);"],"mappings":";;;;;;;;;;;;;;;;;AAAA;AAOA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA9PA;;;;A","sourceRoot":""}